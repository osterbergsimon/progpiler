module Absgrammar where

-- Haskell module generated by the BNF converter


newtype Id = Id ((Int,Int),String) deriving (Eq,Ord,Show)
data Program =
   PDefs [Def]
  deriving (Eq,Ord,Show)

data Def =
   DFun Type Id [Arg] [Stm]
 | DNFun Type Id [Arg]
 | DQC QCList
 | DTypeD Type Id
 | DDecl Dec
 | DStruct Id [Dec]
  deriving (Eq,Ord,Show)

data Arg =
   ArgDecl Argument
 | CArgDecl Argument
  deriving (Eq,Ord,Show)

data Argument =
   ATDecl Type
 | ADecl Type Id
 | ADeclAss Type Id Exp
 | ARDecl Type
 | ARIDecl Type Id
 | ARDeclAss Type Id Exp
  deriving (Eq,Ord,Show)

data Dec =
   Decl Declaration
 | CDecl Declaration
  deriving (Eq,Ord,Show)

data Declaration =
   Del Type [Id]
 | DelAss Type Id Exp
 | RefDel Type [Id]
 | RefDelAss Type Id Exp
  deriving (Eq,Ord,Show)

data Stm =
   SExp Exp
 | SReturn Exp
 | SReturnVoid
 | SWhile Exp Stm
 | SDoWhile Stm Exp
 | SBlock [Stm]
 | SIf Exp Stm
 | SIfElse Exp Stm Stm
 | SFor Type Exp Exp Exp Stm
 | STypedef Type Id
 | SStruct Id [Dec]
 | SDec Dec
  deriving (Eq,Ord,Show)

data Exp =
   EInt Integer
 | EDouble Double
 | EString [String]
 | EChar Char
 | ETrue
 | EFalse
 | ECid QCList
 | ECall Id [Exp]
 | EInd Id Exp
 | EPIncr Exp
 | EPDecr Exp
 | EPStr1 Exp Exp
 | EPStr2 Exp Exp
 | EIncr Exp
 | EDecr Exp
 | ENeg Exp
 | EMul Exp Exp
 | EDiv Exp Exp
 | ERem Exp Exp
 | EAdd Exp Exp
 | ESub Exp Exp
 | ELef Exp Exp
 | ERig Exp Exp
 | ELt Exp Exp
 | EGt Exp Exp
 | ELEq Exp Exp
 | EGEq Exp Exp
 | EEq Exp Exp
 | ENEq Exp Exp
 | EAnd Exp Exp
 | EOr Exp Exp
 | EAss Exp Exp
 | EPAss Exp Exp
 | ENAss Exp Exp
 | ECon Exp Exp Exp
 | EExc Exp
  deriving (Eq,Ord,Show)

data Type =
   Type_bool
 | Type_int
 | Type_double
 | Type_void
 | TypeQCList QCList
  deriving (Eq,Ord,Show)

data QCList =
   QCL [Qcons]
  deriving (Eq,Ord,Show)

data Qcons =
   QId Id
 | QTempi Id [Type]
  deriving (Eq,Ord,Show)

